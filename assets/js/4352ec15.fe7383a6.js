"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7367],{8247:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>i,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"Strategy/Strategy-intro","title":"Introducci\xf3n al patr\xf3n Strategy","description":"El patr\xf3n Strategy pertenece a los patrones de dise\xf1o de comportamiento, cuyo prop\xf3sito principal es mejorar c\xf3mo los objetos interact\xfaan y se relacionan entre s\xed. En este caso, el patr\xf3n facilita la definici\xf3n de una familia de algoritmos, encapsul\xe1ndolos en clases independientes que pueden intercambiarse en tiempo de ejecuci\xf3n sin necesidad de modificar el c\xf3digo que los utiliza. Este enfoque se basa en el principio de programaci\xf3n orientada a objetos conocido como \\"abierto para extensi\xf3n, cerrado para modificaci\xf3n\\", promoviendo la reutilizaci\xf3n de c\xf3digo y el desacoplamiento entre los componentes.","source":"@site/docs/02-Strategy/01-Strategy-intro.md","sourceDirName":"02-Strategy","slug":"/Strategy/Strategy-intro","permalink":"/docosaurus-arq/docs/Strategy/Strategy-intro","draft":false,"unlisted":false,"editUrl":"https://github.com/dazer-m-l/docosaurus-arq/tree/main/docs/docs/02-Strategy/01-Strategy-intro.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Patron Strategy","permalink":"/docosaurus-arq/docs/category/patron-strategy"},"next":{"title":"Caracter\xedsticas del Patr\xf3n Strategy","permalink":"/docosaurus-arq/docs/Strategy/Strategy-Caracteristicas"}}');var o=a(4848),r=a(8453);const i={},s="Introducci\xf3n al patr\xf3n Strategy",c={},d=[];function l(e){const t={h1:"h1",header:"header",img:"img",p:"p",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"introducci\xf3n-al-patr\xf3n-strategy",children:"Introducci\xf3n al patr\xf3n Strategy"})}),"\n",(0,o.jsx)(t.p,{children:'El patr\xf3n Strategy pertenece a los patrones de dise\xf1o de comportamiento, cuyo prop\xf3sito principal es mejorar c\xf3mo los objetos interact\xfaan y se relacionan entre s\xed. En este caso, el patr\xf3n facilita la definici\xf3n de una familia de algoritmos, encapsul\xe1ndolos en clases independientes que pueden intercambiarse en tiempo de ejecuci\xf3n sin necesidad de modificar el c\xf3digo que los utiliza. Este enfoque se basa en el principio de programaci\xf3n orientada a objetos conocido como "abierto para extensi\xf3n, cerrado para modificaci\xf3n", promoviendo la reutilizaci\xf3n de c\xf3digo y el desacoplamiento entre los componentes.'}),"\n",(0,o.jsx)(t.p,{children:"En esencia, el patr\xf3n Strategy consiste en un contexto (la clase principal que realiza una operaci\xf3n) y varias estrategias concretas (clases que implementan diferentes algoritmos o comportamientos). El contexto utiliza una interfaz com\xfan para interactuar con las estrategias, permitiendo que estas sean f\xe1cilmente intercambiables. Esto resulta especialmente \xfatil en escenarios donde se deben soportar m\xfaltiples opciones o variaciones de un comportamiento, como m\xe9todos de pago, t\xe9cnicas de autenticaci\xf3n, estrategias de compresi\xf3n, o algoritmos de b\xfasqueda."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{src:"https://refactoring.guru/images/patterns/content/strategy/strategy.png?id=379bfba335380500375881a3da6507e0",alt:"Strategy Pattern"})})]})}function p(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},8453:(e,t,a)=>{a.d(t,{R:()=>i,x:()=>s});var n=a(6540);const o={},r=n.createContext(o);function i(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);